## 1.请说一下响应式数据的理解？
    vue的响应式原理使用Object.defineProperty对data中的每个属性循环递归并重新定义get和set方法，当在定义get方法是通过给每个属性存放一个dep类进行依赖收集存放对应watcher，当去set跟新时从dep中依次取出对应收集的watcher并触发watcher的跟新方法重新执行render并跟新视图
    
## 2.Vue中如何检测数组变化？
    处于对数组中元素递归性能考虑，通过函数劫持重写了数组原有的push/pop/shift/unshift/reverse/sort/splice并继承原数组类，并在重写方法中为跟新的属性添加观测，使其也达到响应式效果

请说一下响应式数据的理解？
    ♥ 核心点考察的是：数组和对象类型当值变化时如何劫持到。对象内部通过defineReactive方法，使用Object.defineProperty将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。 这里在回答时可以带出一些相关知识点（比如多层对象是通过递归来实现劫持，顺带提出Vue3中是使用proxy来实现响应式数据）

    ♥ 核心点答出来了也可以在进行补充回答，内部依赖收集是怎样做到的，每个属性都拥有自己的dep属性，存放他所依赖的watcher，当属性变化后会通知自己对应的watcher去更新 （其实后面会讲到每个对象类型自己本身也拥有一个dep属性，这个在$set面试题中在进行讲解）

    ♥这里可以引出性能优化相关的内容 （1）对象层级过深，性能就会差 （2）不需要响应数据的内容不要放到data中 （3） Object.freeze() 可以冻结数据

Vue如何检测数组变化？
    ♥ 核心点考察的是：数组考虑性能原因没有用defineProperty对数组的每一项进行拦截，而是选择重写数组（push,shift,pop,splice,unshift,sort,reverse）方法进行重写。

    ♥ 核心点答出来了也可以在进行补充回答，在Vue中修改数组的索引和长度是无法监控到的。需要通过以上7种变异方法修改数组才会触发数组对应的watcher进行更新。数组中如果是对象数据类型也会进行递归劫持。

    ♥ 引发出的问题，那如果想更改索引更新数据怎么办？可以通过Vue.$set()来进行处理 =》 核心内部用的是splice方法